//
//  Render.h
//  NinjaTraining
//
//  Created by Tommaso Checchi on 4/23/10.
//  Copyright 2010 __MyCompanyName__. All rights reserved.
//
#ifndef Render_h__
#define Render_h__

#include "dojo_config.h"

#import <OpenGLES/EAGL.h>
#import <OpenGLES/EAGLDrawable.h>
#import <UIKit/UIKit.h>
#import <QuartzCore/QuartzCore.h>


#include <OpenGLES/ES1/gl.h>
#include <OpenGLES/ES1/glext.h>
#include "Array.h"

#include "Color.h"
#include "Vector.h"
#include "RenderState.h"

namespace Dojo {
	
	class Renderable;
	class Texture;
	class Viewport;
	class Mesh;
	
	class Render
	{	
	public:				
		
		enum InterfaceOrientation
		{
			IO_PORTRAIT,
			IO_PORTRAIT_REVERSE,
			IO_LANDSCAPE_LEFT,
			IO_LANDSCAPE_RIGHT
		};
		
		typedef Array< RenderTarget* > RenderTargetList;
						
		Render();		
		
		~Render();		
				
		bool resizeFromLayer( CAEAGLLayer* layer );
			
		inline void setWindowSize(uint w, uint h) 
		{
			width = (float)w;
			height = (float)h;
		}
		
		///registers a new render target for rendering
		inline void registerRenderTarget( RenderTarget* r )
		{
			DOJO_ASSERT( r );
			DOJO_ASSERT( !renderTargets.exists( r ) );
			
			renderTargets.addElement( r );
		}
				
		inline void setInterfaceOrientation( InterfaceOrientation o )		
		{	
			interfaceOrientation = o;
			
			static float orientations[] = 	{ 0, 180, -90, 90 };
			
			interfaceRotation = orientations[ (uint)interfaceOrientation ];
		}
				
		inline float getWidth()						{	return width;		}
		inline float getHeight()					{	return height;		}
						
		inline InterfaceOrientation getInterfaceOrientation()					
		{	
			return interfaceOrientation;	
		}
		
		inline float getInterfaceRotation()				
		{	
			return interfaceRotation;		
		}
				
		inline bool isValid()						{	return valid;		}
						
		void startFrame();
		
		void renderElement( Renderable* r );
				
		void endFrame();
		
		///renders all the layers and their contained Renderables in the given order
		/**
		for each RenderTarget listed, it will render the related Scene in its framebuffer.
		 */
		void render()
		{			
			DOJO_ASSERT( renderTargets.size() );
			
			startFrame();
			
			for( uint i = 0; i < renderTargets.size(); ++i )
				renderTargets.at(i)->render();
						
			endFrame();
		}
				
	protected:	
		
		EAGLContext *context;	
		bool valid;
						
		// The pixel dimensions of the CAEAGLLayer
		float width;
		float height;
		
		float interfaceRotation;		
		InterfaceOrientation interfaceOrientation;
		
		// The OpenGL names for the framebuffer and renderbuffer used to render to this view
		GLuint defaultFramebuffer, colorRenderbuffer;
		
		RenderTargetList renderTargets;
				
		Viewport* viewport;	
		Vector viewportPixelRatio, textureScreenPixelRatio, spriteScreenPixelSize;
		
		RenderState* currentRenderState, *firstRenderState;
						
		bool frameStarted;
	};		
}

#endif